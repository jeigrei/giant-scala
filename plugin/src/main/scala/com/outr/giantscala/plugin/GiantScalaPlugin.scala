package com.outr.giantscala.plugin

import java.nio.file.attribute.BasicFileAttributes
import java.nio.file.{Files, Path}

import sbt._
import Keys._

import scala.collection.JavaConverters._
import scala.reflect.internal.util.ScalaClassLoader.URLClassLoader

object GiantScalaPlugin extends sbt.AutoPlugin {
  override def trigger: PluginTrigger = allRequirements

  object autoImport {
    lazy val generateDBModels = TaskKey[Unit]("generateDBModels", "Generates database models for giant-scala from case classes extending ModelObject")
    lazy val dbModelsDirectory = SettingKey[File]("dbModelsDirectory", "The output directory for generated models")
  }

  import autoImport._

  override lazy val projectSettings: Seq[Def.Setting[_]] = Seq(
    dbModelsDirectory := {
      sourceDirectories.in(Runtime).value.find { file =>
        file.isDirectory && file.listFiles().nonEmpty
      }.getOrElse(sourceDirectory.in(Runtime).value)
    },
    generateDBModels := {
      val classPath = fullClasspath.in(Runtime).value
      val urls = classPath.map(_.data.toURI.toURL)
      val classLoader = new URLClassLoader(urls, null)
      val dir = classPath.head.data.toPath
      val modelObjectInterface = classLoader.loadClass("com.outr.giantscala.ModelObject")
      val classes: List[String] = Files.find(dir, Int.MaxValue, (path: Path, _: BasicFileAttributes) => {
        path.toString.toLowerCase.endsWith(".class")
      })
        .iterator()
        .asScala
        .toList
        .map(dir.relativize)
        .map(_.toString.replace('/', '.'))
        .map(c => c.substring(0, c.length - 6))
        .filterNot(_.endsWith("$"))
        .distinct
      val outDirectory = dbModelsDirectory.in(Runtime).value
      outDirectory.mkdirs()
      classes.foreach { c =>
        val clazz = classLoader.loadClass(c)
        val isModelObject = modelObjectInterface.isAssignableFrom(clazz)
        if (isModelObject && !clazz.isInterface) {
          import scala.reflect.runtime.universe._

          val m = runtimeMirror(classLoader)

          // TODO: support recursively built fields list, breaking into sub-objects supporting Option[case class] and Seq[case class]
          val classSymbol = m.classSymbol(clazz)
          val classMirror = m.reflectClass(classSymbol)
          val moduleSymbol = classMirror.symbol.companion
          val apply = moduleSymbol
            .typeSignature
            .decls
            .filter(_.isMethod)
            .filter(_.asMethod.name.toTermName == TermName("apply"))
            .map(_.asMethod)
            .last
          val params = apply.paramLists.head.map(_.asTerm)
          val fields = params.map { p =>
            val `type` = p.typeSignature.resultType.toString.replaceAllLiterally("Predef.", "")
            object CaseField {
              def unapply(trmSym: TermSymbol): Option[(Name, Type)] = {
                if (trmSym.isVal && trmSym.isCaseAccessor)
                  Some((TermName(trmSym.name.toString.trim), trmSym.typeSignature))
                else
                  None
              }
            }
            val caseEntries = p.typeSignature.resultType.decls.collect {
              case CaseField(nme, tpe) => (nme, tpe)
            }.toList
            val name = p.name.decodedName.toString
            val encName = encodedName(name)
            if (caseEntries.isEmpty) {
              s"""val $encName: Field[${`type`}] = Field[${`type`}]("$name")"""
            } else {
              val subFields = caseEntries.map {
                case (nme, tpe) => {
                  val subType = tpe.toString.replaceAllLiterally("Predef.", "")
                  s"""val ${encodedName(nme.decodedName.toString)}: Field[$subType] = Field[$subType]("$name.$nme")"""
                }
              }
              s"""object $encName extends Field[${`type`}]("$name") {
                 |    ${subFields.mkString("\n    ")}
                 |  }""".stripMargin
            }
          }
          val source =
            s"""
               |package ${clazz.getPackage.getName}
               |
               |import com.outr.giantscala._
               |
               |/**
               | * WARNING: This file was generated by giant-scala's SBT plugin generateDBModels. Do not edit directly.
               | */
               |abstract class ${clazz.getSimpleName}Model(collectionName: String, db: MongoDatabase) extends DBCollection[${clazz.getSimpleName}](collectionName, db) {
               |  override val converter: Converter[${clazz.getSimpleName}] = Converter.auto[${clazz.getSimpleName}]
               |
               |  ${fields.mkString("\n  ")}
               |}
             """.stripMargin.trim
          val sourceDir = new File(outDirectory, clazz.getPackage.getName.replace('.', '/'))
          val sourceFile = new File(sourceDir, s"${clazz.getSimpleName}Model.scala")
          val sourcePath = sourceFile.toPath
          Files.deleteIfExists(sourcePath)
          Files.createFile(sourcePath)
          Files.write(sourcePath, source.getBytes)
          println(s"Created ${sourceFile.getCanonicalPath} successfully")
        }
      }
    }
  )

  private def encodedName(name: String): String = name match {
    case "type" => "`type`"
    case _ => name
  }
}

case class ModelDetails(className: String, args: List[ModelArg], path: Path, packageName: String) {
  override def toString: String = s"$className(${args.mkString(", ")})"
}

case class ModelArg(name: String, `type`: String) {
  override def toString: String = s"$name: ${`type`}"
}